///
/// JHybridUniFileSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridUniFileSpec.hpp"

// Forward declaration of `HybridUniFileSpec` to properly resolve imports.
namespace margelo::nitro::unifile { class HybridUniFileSpec; }

#include <string>
#include <optional>
#include <memory>
#include "HybridUniFileSpec.hpp"
#include "JHybridUniFileSpec.hpp"
#include <NitroModules/JNISharedPtr.hpp>
#include <vector>

namespace margelo::nitro::unifile {

  jni::local_ref<JHybridUniFileSpec::jhybriddata> JHybridUniFileSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridUniFileSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridUniFileSpec::initHybrid),
    });
  }

  size_t JHybridUniFileSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  // Properties
  std::string JHybridUniFileSpec::getUri() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getUri");
    auto __result = method(_javaPart);
    return __result->toStdString();
  }
  void JHybridUniFileSpec::setUri(const std::string& uri) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* uri */)>("setUri");
    method(_javaPart, jni::make_jstring(uri));
  }
  std::optional<std::string> JHybridUniFileSpec::getFileName() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getFileName");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridUniFileSpec::setFileName(const std::optional<std::string>& fileName) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* fileName */)>("setFileName");
    method(_javaPart, fileName.has_value() ? jni::make_jstring(fileName.value()) : nullptr);
  }
  std::optional<std::string> JHybridUniFileSpec::getType() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getType");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridUniFileSpec::setType(const std::optional<std::string>& type) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* type */)>("setType");
    method(_javaPart, type.has_value() ? jni::make_jstring(type.value()) : nullptr);
  }
  std::optional<std::string> JHybridUniFileSpec::getFilePath() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getFilePath");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridUniFileSpec::setFilePath(const std::optional<std::string>& filePath) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* filePath */)>("setFilePath");
    method(_javaPart, filePath.has_value() ? jni::make_jstring(filePath.value()) : nullptr);
  }
  std::optional<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>> JHybridUniFileSpec::getParentFile() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridUniFileSpec::javaobject>()>("getParentFile");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(JNISharedPtr::make_shared_from_jni<JHybridUniFileSpec>(jni::make_global(__result))) : std::nullopt;
  }
  void JHybridUniFileSpec::setParentFile(const std::optional<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>>& parentFile) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JHybridUniFileSpec::javaobject> /* parentFile */)>("setParentFile");
    method(_javaPart, parentFile.has_value() ? std::dynamic_pointer_cast<JHybridUniFileSpec>(parentFile.value())->getJavaPart() : nullptr);
  }
  bool JHybridUniFileSpec::getIsDirectory() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("isDirectory");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  void JHybridUniFileSpec::setIsDirectory(bool isDirectory) {
    static const auto method = javaClassStatic()->getMethod<void(jboolean /* isDirectory */)>("setDirectory");
    method(_javaPart, isDirectory);
  }
  bool JHybridUniFileSpec::getIsFile() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("isFile");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  void JHybridUniFileSpec::setIsFile(bool isFile) {
    static const auto method = javaClassStatic()->getMethod<void(jboolean /* isFile */)>("setFile");
    method(_javaPart, isFile);
  }
  std::optional<std::string> JHybridUniFileSpec::getExtension() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getExtension");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridUniFileSpec::setExtension(const std::optional<std::string>& extension) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* extension */)>("setExtension");
    method(_javaPart, extension.has_value() ? jni::make_jstring(extension.value()) : nullptr);
  }
  std::optional<std::string> JHybridUniFileSpec::getNameWithoutExtension() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getNameWithoutExtension");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toStdString()) : std::nullopt;
  }
  void JHybridUniFileSpec::setNameWithoutExtension(const std::optional<std::string>& nameWithoutExtension) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* nameWithoutExtension */)>("setNameWithoutExtension");
    method(_javaPart, nameWithoutExtension.has_value() ? jni::make_jstring(nameWithoutExtension.value()) : nullptr);
  }
  std::string JHybridUniFileSpec::getDisplayablePath() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("getDisplayablePath");
    auto __result = method(_javaPart);
    return __result->toStdString();
  }
  void JHybridUniFileSpec::setDisplayablePath(const std::string& displayablePath) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JString> /* displayablePath */)>("setDisplayablePath");
    method(_javaPart, jni::make_jstring(displayablePath));
  }

  // Methods
  bool JHybridUniFileSpec::exists() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("exists");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  std::optional<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>> JHybridUniFileSpec::findFile(const std::string& path) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridUniFileSpec::javaobject>(jni::alias_ref<jni::JString> /* path */)>("findFile");
    auto __result = method(_javaPart, jni::make_jstring(path));
    return __result != nullptr ? std::make_optional(JNISharedPtr::make_shared_from_jni<JHybridUniFileSpec>(jni::make_global(__result))) : std::nullopt;
  }
  std::vector<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>> JHybridUniFileSpec::listFiles() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayClass<JHybridUniFileSpec::javaobject>>()>("listFiles");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>> __vector;
      __vector.reserve(__size);
      for (size_t __i = 0; __i < __size; __i++) {
        auto __element = __result->getElement(__i);
        __vector.push_back(JNISharedPtr::make_shared_from_jni<JHybridUniFileSpec>(jni::make_global(__element)));
      }
      return __vector;
    }();
  }
  bool JHybridUniFileSpec::deleteFile() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("deleteFile");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  std::optional<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>> JHybridUniFileSpec::createDirectory(const std::string& displayName) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridUniFileSpec::javaobject>(jni::alias_ref<jni::JString> /* displayName */)>("createDirectory");
    auto __result = method(_javaPart, jni::make_jstring(displayName));
    return __result != nullptr ? std::make_optional(JNISharedPtr::make_shared_from_jni<JHybridUniFileSpec>(jni::make_global(__result))) : std::nullopt;
  }
  std::optional<std::shared_ptr<margelo::nitro::unifile::HybridUniFileSpec>> JHybridUniFileSpec::createFile(const std::string& displayName) {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JHybridUniFileSpec::javaobject>(jni::alias_ref<jni::JString> /* displayName */)>("createFile");
    auto __result = method(_javaPart, jni::make_jstring(displayName));
    return __result != nullptr ? std::make_optional(JNISharedPtr::make_shared_from_jni<JHybridUniFileSpec>(jni::make_global(__result))) : std::nullopt;
  }
  bool JHybridUniFileSpec::renameTo(const std::string& displayName) {
    static const auto method = javaClassStatic()->getMethod<jboolean(jni::alias_ref<jni::JString> /* displayName */)>("renameTo");
    auto __result = method(_javaPart, jni::make_jstring(displayName));
    return static_cast<bool>(__result);
  }
  std::string JHybridUniFileSpec::lastModified() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("lastModified");
    auto __result = method(_javaPart);
    return __result->toStdString();
  }
  std::string JHybridUniFileSpec::length() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JString>()>("length");
    auto __result = method(_javaPart);
    return __result->toStdString();
  }
  bool JHybridUniFileSpec::canRead() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("canRead");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }
  bool JHybridUniFileSpec::canWrite() {
    static const auto method = javaClassStatic()->getMethod<jboolean()>("canWrite");
    auto __result = method(_javaPart);
    return static_cast<bool>(__result);
  }

} // namespace margelo::nitro::unifile
